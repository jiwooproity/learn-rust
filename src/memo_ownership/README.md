# Rust 소유권 ( Ownership )

기존 **C / C++** 과 같은 언어들은 Heap 메모리를 할당한 후, 개발자가 수동으로 메모리를 해제하는 코드를 작성하여 메모리를 관리했다.

**Java**나 **C#**과 같은 언어들은 **가비지 컬렉터 ( GC )** 를 사용하여 객체의 레퍼런스를 트래킹하고,

객체가 더 이상 사용되지 않는 지 판단하여 런타임 환경에서 Heap 메모리를 해제하는 방식을 사용했다.

**Rust**에서는 컴파일 단계에서 Heap 메모리가 언제 해제되는 지를 알아내고, 컴파일러가 메모리 해제코드를 자동으로 추가하는 방식을 사용한다.

이러한 메모리 관리를 위해 Rust의 **Ownership ( 소유권 )** 이라는 개념을 사용한다.

## Rust의 Ownership 규칙

- Rust에서 각각의 데이터는 항상 소유자라고 불리는 하나의 변수를 갖는다.
- 항상 하나의 Ownership만을 가진다.
- Ownership은 블록을 벗어날 때, 데이터는 <code>drop</code> 된다.

## Rust 소유권을 알아보기 전 스택과 힙에 대하여

Rust와 같은 시스템 프로그래밍 언어에서는 값이 스택에 있는 지와 힙에 있는 지에 따라 동작이 달라진다.

스택에 담긴 몯느 데이터는 결정되어 있는 고정된 크기를 갖고 있는다.

반면, 힙은 컴파일 시에 결정되어 있지 않거나 크기가 변경될 수 있는 데이터를 위해 사용한다.

힙에 데이터를 넣을 때, 먼저 저장할 공간이 있는 지 확인하고 빈 공간을 찾아 사용중으로 변경한다.

변경된 힙 공간은 해당 지점의 포인터를 돌려준다. 이러한 절차를 "할당" 한다고 이야기 합니다.

코드의 어느 부분이 힙의 데이터를 사용하는 지 추적, 힙의 중복된 데이터의 양을 최소화하는 것 ..

힙 내에 사용하지 않는 데이터를 해제하여 공간을 효율적으로 관리할 수 있도록 하는 것이 소유권의 존재 이유입니다.

## 블록에 따른 유효 지점

```
fn main() {
  {
    let s: &str = "Hello"; // s 변수의 유효 지점
    println!("s = {}", s); // Hello
  }

  // 블록을 빠져나온 후, s의 유효 상태
  println!("s = {}", s); // Error: cannot find value `sdad` in this scope
}
```

... 작성 중
