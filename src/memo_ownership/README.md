# Rust 소유권 ( Ownership )

기존 **C / C++** 과 같은 언어들은 Heap 메모리를 할당한 후, 개발자가 수동으로 메모리를 해제하는 코드를 작성하여 메모리를 관리했다.

**Java**나 **C#**과 같은 언어들은 **가비지 컬렉터 ( GC )** 를 사용하여 객체의 레퍼런스를 트래킹하고,

객체가 더 이상 사용되지 않는 지 판단하여 런타임 환경에서 Heap 메모리를 해제하는 방식을 사용했다.

**Rust**에서는 컴파일 단계에서 Heap 메모리가 언제 해제되는 지를 알아내고, 컴파일러가 메모리 해제코드를 자동으로 추가하는 방식을 사용한다.

이러한 메모리 관리를 위해 Rust의 **Ownership ( 소유권 )** 이라는 개념을 사용한다.

## Rust의 Ownership 규칙

- Rust에서 각각의 데이터는 항상 소유자라고 불리는 하나의 변수를 갖는다.
- 항상 하나의 Ownership만을 가진다.
- Ownership은 블록을 벗어날 때, 데이터는 <code>drop</code> 된다.

## Rust 소유권을 알아보기 전 스택과 힙에 대하여

Rust와 같은 시스템 프로그래밍 언어에서는 값이 스택에 있는 지와 힙에 있는 지에 따라 동작이 달라진다.

스택에 담긴 몯느 데이터는 결정되어 있는 고정된 크기를 갖고 있는다.

반면, 힙은 컴파일 시에 결정되어 있지 않거나 크기가 변경될 수 있는 데이터를 위해 사용한다.

힙에 데이터를 넣을 때, 먼저 저장할 공간이 있는 지 확인하고 빈 공간을 찾아 사용중으로 변경한다.

변경된 힙 공간은 해당 지점의 포인터를 돌려준다. 이러한 절차를 "할당" 한다고 이야기 합니다.

코드의 어느 부분이 힙의 데이터를 사용하는 지 추적, 힙의 중복된 데이터의 양을 최소화하는 것 ..

힙 내에 사용하지 않는 데이터를 해제하여 공간을 효율적으로 관리할 수 있도록 하는 것이 소유권의 존재 이유입니다.

## Rust의 Ownership 메모리 관리

GC는 더 이상 사용되지 않는 참조 값에 대해 계산을 하고 해제하는 작업을 한다.

Java, JavaScript의 GC가 JVM, JavaScript V8 Engine에 의해 자동으로 메모리가 관리되면서 개발자가 직접 메모리를 신경쓰고 그럴 필요가 없다.

반대로 C / C++ 과 같은 언어에서는 직접 개발자가 쓰지 않는 참조에 대해 직접 해제하고 관리해야 한다.

그러면 Rust에서는 GC가 없는데 어째서 참조 상태를 예측하여 <code>drop</code> 으로 메모리 해제가 가능하게 되는 것일까?

이 내용은 Rust의 소유권 개념을 이해할 필요가 있다. 먼저 Rust 문법으로 작성된 코드를 살펴보자.

```
fn main() {
  let a: String = String::from("Hello"); // String 타입 "Hello" 할당
  let b: String = a; // a의 값은 b에 할당

  // println!("a = {}", a); // Error: value borrowed here after move
  println!("b = {}", b); // "b = Hello"
}
```

내용을 살펴보면 String 타입으로 작성된 Hello 문자열이 a라는 변수에 할당되고, b로 옮겨가게 되었다.

Heap 객체는 이곳 저곳 바인딩되거나 변경이 될 수가 있는데, Rust는 하나의 소유권만을 가지기 때문에 다른 곳에 바인딩되면 소유권이 변경되게 됩니다.

코드로 보면 a에 할당되었던 문자열이 b에 할당되면서 변수 a의 소유권이 b로 옮겨지게 된 것으로 a는 더 이상 사용할 수 없는 값이 됩니다.

이 소유권이 옮겨지는 것을 Rust에서는 <code>move</code> 라는 표현을 사용합니다.

정리하자면, 코드에서 a의 소유권이 b로 이동하면서 a는 더 이상 사용할 수 없도록 <code>drop</code> 이 되며, 이것을 변수의 무효화 <code>invalid</code> 처리를 합니다.

이러한 소유권 개념을 통해 Rust는 컴파일 타임에 어느 참조가 해제가 되어야 하는 지를 파악하고 drop을 통해 invalid 처리를 진행하며 메모리 관리를 합니다.

따라서, Rust의 소유권 개념으로 메모리, 스레드의 안정성이 보장되는 것이라고 볼 수 있습니다.

## Rust 인수 전달

Rust에서 함수 인수로 전달하여 사용될 경우 함수에게 소유권이 넘겨져 더 이상 사용이 불가능한 invalid 변수가 발생할 수 있습니다.

이러한 처리는 어떻게 관리하면 좋을까? 아래 코드로 살펴보자

```
fn main() {
  let a: i32 = 5;

  let b = add_calc(a); // 반환된 값을 다시 새로운 변수 b에 할당하여 소유권 흭득
}

fn add_calc(a: i32) -> i32 {
  a // 세미콜론 ( ; ) 을 제외하면 Rust에서는 값을 리턴하는 표현식으로서 값을 반환한다.
}
```

이처럼 add_calc() 함수로 넘어간 소유권은 따로 반환하지 않고 사용하게 된다면 add_calc() 함수의 블록을 빠져나오게 될 경우 <code>drop</code> 되게 된다.

하지만, 소유권을 함수로 넘겼던 변수를 계속 사용해야 하는 경우, 해당 함수 안에서 Expression을 통해 값을 반환하고 새로운 값에 할당하여 소유권을 얻으면 된다.

**Statement** 값을 리턴하지 않는 문장이다.
**Expression** 값을 리턴하는 수식을 의미한다.
